/**
 * @process specializations/security-compliance/vulnerability-management
 * @description Vulnerability Management Lifecycle - Comprehensive end-to-end vulnerability management process covering
 * continuous scanning, validation and triage, risk-based prioritization using CVSS/EPSS, remediation tracking,
 * verification, and MTTD/MTTR metrics reporting. Implements industry best practices for managing security
 * vulnerabilities across application portfolios with automated workflows and SLA tracking.
 * @inputs { projectName: string, assetScope?: array, scanTypes?: array, riskThreshold?: string, complianceFrameworks?: array }
 * @outputs { success: boolean, vulnerabilityScore: number, vulnerabilities: array, remediationStatus: object, metrics: object, artifacts: array }
 *
 * @example
 * const result = await orchestrate('specializations/security-compliance/vulnerability-management', {
 *   projectName: 'E-Commerce Platform',
 *   assetScope: ['applications', 'infrastructure', 'containers', 'dependencies'],
 *   scanTypes: ['sast', 'dast', 'sca', 'container', 'infrastructure', 'network'],
 *   riskThreshold: 'high', // 'critical', 'high', 'medium', 'low'
 *   complianceFrameworks: ['PCI-DSS', 'SOC2', 'ISO27001', 'NIST'],
 *   prioritizationMethod: 'cvss-epss', // 'cvss', 'epss', 'cvss-epss', 'custom'
 *   slaTargets: {
 *     critical: { mttr: 24, unit: 'hours' },
 *     high: { mttr: 7, unit: 'days' },
 *     medium: { mttr: 30, unit: 'days' },
 *     low: { mttr: 90, unit: 'days' }
 *   },
 *   autoRemediation: true,
 *   continuousScanning: true,
 *   falsePositiveManagement: true
 * });
 *
 * @references
 * - NIST SP 800-40: Vulnerability Management: https://csrc.nist.gov/publications/detail/sp/800-40/rev-4/final
 * - CVSS v3.1 Specification: https://www.first.org/cvss/v3.1/specification-document
 * - EPSS (Exploit Prediction Scoring System): https://www.first.org/epss/
 * - OWASP Vulnerability Management Guide: https://owasp.org/www-community/Vulnerability_Scanning_Tools
 * - CIS Controls v8 - Vulnerability Management: https://www.cisecurity.org/controls/
 * - CISA Known Exploited Vulnerabilities: https://www.cisa.gov/known-exploited-vulnerabilities-catalog
 */

import { defineTask } from '@a5c-ai/babysitter-sdk';

export async function process(inputs, ctx) {
  const {
    projectName,
    assetScope = ['applications', 'infrastructure', 'containers', 'dependencies'],
    scanTypes = ['sast', 'dast', 'sca', 'container', 'infrastructure'],
    riskThreshold = 'medium', // minimum severity to track
    complianceFrameworks = [],
    prioritizationMethod = 'cvss-epss', // 'cvss', 'epss', 'cvss-epss', 'custom'
    slaTargets = {
      critical: { mttr: 24, unit: 'hours' },
      high: { mttr: 7, unit: 'days' },
      medium: { mttr: 30, unit: 'days' },
      low: { mttr: 90, unit: 'days' }
    },
    outputDir = 'vulnerability-management-output',
    autoRemediation = false,
    continuousScanning = true,
    falsePositiveManagement = true,
    integrations = {
      ticketing: 'jira', // 'jira', 'servicenow', 'github', 'linear'
      scanners: ['snyk', 'trivy', 'sonarqube', 'nessus'],
      notifications: ['email', 'slack', 'teams']
    },
    environment = 'production',
    portfolioView = true
  } = inputs;

  const startTime = ctx.now();
  const artifacts = [];
  let vulnerabilityScore = 0;
  const vulnerabilities = [];
  const remediationTracking = [];
  const metrics = {
    mttd: 0, // Mean Time To Detect
    mttr: 0, // Mean Time To Remediate
    totalVulnerabilities: 0,
    criticalCount: 0,
    highCount: 0,
    mediumCount: 0,
    lowCount: 0,
    remediatedCount: 0,
    openCount: 0,
    falsePositiveCount: 0
  };

  ctx.log('info', `Starting Vulnerability Management Lifecycle for ${projectName}`);
  ctx.log('info', `Asset Scope: ${assetScope.join(', ')}`);
  ctx.log('info', `Scan Types: ${scanTypes.join(', ')}, Risk Threshold: ${riskThreshold}`);
  ctx.log('info', `Prioritization: ${prioritizationMethod}, Auto-Remediation: ${autoRemediation}`);

  // ============================================================================
  // PHASE 1: ASSET DISCOVERY AND INVENTORY
  // ============================================================================

  ctx.log('info', 'Phase 1: Discovering and inventorying assets');

  const assetInventoryResult = await ctx.task(discoverAssetsTask, {
    projectName,
    assetScope,
    environment,
    portfolioView,
    outputDir
  });

  artifacts.push(...assetInventoryResult.artifacts);

  ctx.log('info', `Asset inventory complete - ${assetInventoryResult.totalAssets} assets discovered across ${assetInventoryResult.assetTypes.length} types`);

  // Quality Gate: Asset inventory review
  await ctx.breakpoint({
    question: `Asset inventory complete for ${projectName}. Discovered ${assetInventoryResult.totalAssets} assets. Review asset coverage before scanning?`,
    title: 'Asset Inventory Review',
    context: {
      runId: ctx.runId,
      inventory: {
        totalAssets: assetInventoryResult.totalAssets,
        assetTypes: assetInventoryResult.assetTypes,
        applications: assetInventoryResult.applications?.length || 0,
        infrastructure: assetInventoryResult.infrastructure?.length || 0,
        containers: assetInventoryResult.containers?.length || 0,
        dependencies: assetInventoryResult.dependencies?.length || 0
      },
      assetBreakdown: assetInventoryResult.assetBreakdown,
      files: assetInventoryResult.artifacts.map(a => ({ path: a.path, format: a.format || 'json', label: a.label }))
    }
  });

  // ============================================================================
  // PHASE 2: CONTINUOUS VULNERABILITY SCANNING
  // ============================================================================

  ctx.log('info', 'Phase 2: Executing continuous vulnerability scanning');

  const scanningResult = await ctx.task(executeVulnerabilityScanningTask, {
    projectName,
    assets: assetInventoryResult.assets,
    scanTypes,
    integrations,
    continuousScanning,
    outputDir
  });

  artifacts.push(...scanningResult.artifacts);
  vulnerabilities.push(...scanningResult.vulnerabilities);

  ctx.log('info', `Vulnerability scanning complete - ${scanningResult.totalFindings} findings identified from ${scanningResult.scannersUsed.length} scanners`);

  // Quality Gate: Initial scan results review
  await ctx.breakpoint({
    question: `Vulnerability scanning complete. ${scanningResult.totalFindings} findings identified. Critical: ${scanningResult.criticalFindings}, High: ${scanningResult.highFindings}. Proceed with triage?`,
    title: 'Vulnerability Scan Results Review',
    context: {
      runId: ctx.runId,
      scanning: {
        totalFindings: scanningResult.totalFindings,
        criticalFindings: scanningResult.criticalFindings,
        highFindings: scanningResult.highFindings,
        mediumFindings: scanningResult.mediumFindings,
        lowFindings: scanningResult.lowFindings,
        scannersUsed: scanningResult.scannersUsed,
        scanCoverage: scanningResult.scanCoverage
      },
      topVulnerabilities: scanningResult.vulnerabilities.slice(0, 10).map(v => ({
        id: v.id,
        title: v.title,
        severity: v.severity,
        cvss: v.cvss,
        asset: v.asset
      })),
      files: scanningResult.artifacts.map(a => ({ path: a.path, format: a.format || 'json', label: a.label }))
    }
  });

  // ============================================================================
  // PHASE 3: VALIDATION AND DEDUPLICATION
  // ============================================================================

  ctx.log('info', 'Phase 3: Validating findings and deduplicating vulnerabilities');

  const validationResult = await ctx.task(validateAndDeduplicateTask, {
    projectName,
    vulnerabilities: scanningResult.vulnerabilities,
    falsePositiveManagement,
    historicalData: true,
    outputDir
  });

  artifacts.push(...validationResult.artifacts);

  ctx.log('info', `Validation complete - ${validationResult.validatedVulnerabilities} confirmed, ${validationResult.duplicatesRemoved} duplicates removed, ${validationResult.falsePositives} false positives`);

  // ============================================================================
  // PHASE 4: RISK-BASED PRIORITIZATION (CVSS/EPSS)
  // ============================================================================

  ctx.log('info', 'Phase 4: Performing risk-based prioritization using CVSS and EPSS');

  const prioritizationResult = await ctx.task(prioritizeVulnerabilitiesTask, {
    projectName,
    vulnerabilities: validationResult.validatedVulnerabilitiesList,
    prioritizationMethod,
    riskThreshold,
    complianceFrameworks,
    cisaKevCheck: true, // Check against CISA Known Exploited Vulnerabilities
    businessContext: true,
    outputDir
  });

  artifacts.push(...prioritizationResult.artifacts);

  ctx.log('info', `Prioritization complete - ${prioritizationResult.prioritizedVulnerabilities} vulnerabilities scored and ranked`);

  // Quality Gate: Prioritization review
  await ctx.breakpoint({
    question: `Vulnerability prioritization complete using ${prioritizationMethod}. ${prioritizationResult.criticalPriority} critical priority items. Review prioritization before remediation?`,
    title: 'Vulnerability Prioritization Review',
    context: {
      runId: ctx.runId,
      prioritization: {
        method: prioritizationMethod,
        totalPrioritized: prioritizationResult.prioritizedVulnerabilities,
        criticalPriority: prioritizationResult.criticalPriority,
        highPriority: prioritizationResult.highPriority,
        cisaKevMatches: prioritizationResult.cisaKevMatches,
        avgCvssScore: prioritizationResult.avgCvssScore,
        avgEpssScore: prioritizationResult.avgEpssScore
      },
      topPriorityVulnerabilities: prioritizationResult.vulnerabilitiesList.slice(0, 15).map(v => ({
        id: v.id,
        title: v.title,
        severity: v.severity,
        cvss: v.cvss,
        epss: v.epss,
        priorityScore: v.priorityScore,
        cisaKev: v.cisaKev,
        asset: v.asset
      })),
      files: prioritizationResult.artifacts.map(a => ({ path: a.path, format: a.format || 'json', label: a.label }))
    }
  });

  // ============================================================================
  // PHASE 5: REMEDIATION ASSIGNMENT AND TRACKING
  // ============================================================================

  ctx.log('info', 'Phase 5: Assigning vulnerabilities for remediation and setting up tracking');

  const assignmentResult = await ctx.task(assignRemediationTask, {
    projectName,
    vulnerabilities: prioritizationResult.vulnerabilitiesList,
    slaTargets,
    integrations,
    autoRemediation,
    outputDir
  });

  artifacts.push(...assignmentResult.artifacts);
  remediationTracking.push(...assignmentResult.remediationTickets);

  ctx.log('info', `Remediation assignment complete - ${assignmentResult.ticketsCreated} tickets created, ${assignmentResult.autoRemediationQueued} queued for auto-remediation`);

  // Quality Gate: Remediation assignment review
  await ctx.breakpoint({
    question: `Remediation assignment complete. ${assignmentResult.ticketsCreated} tickets created across ${assignmentResult.teamsAssigned} teams. ${assignmentResult.autoRemediationQueued} items queued for auto-remediation. Approve remediation plan?`,
    title: 'Remediation Assignment Review',
    context: {
      runId: ctx.runId,
      assignment: {
        ticketsCreated: assignmentResult.ticketsCreated,
        teamsAssigned: assignmentResult.teamsAssigned,
        autoRemediationQueued: assignmentResult.autoRemediationQueued,
        criticalAssignments: assignmentResult.criticalAssignments,
        slaBreaches: assignmentResult.potentialSlaBreaches
      },
      remediationBreakdown: assignmentResult.remediationBreakdown,
      files: assignmentResult.artifacts.map(a => ({ path: a.path, format: a.format || 'json', label: a.label }))
    }
  });

  // ============================================================================
  // PHASE 6: AUTOMATED REMEDIATION (WHERE APPLICABLE)
  // ============================================================================

  if (autoRemediation && assignmentResult.autoRemediationQueued > 0) {
    ctx.log('info', 'Phase 6: Executing automated remediation for eligible vulnerabilities');

    const autoRemediationResult = await ctx.task(executeAutoRemediationTask, {
      projectName,
      vulnerabilities: assignmentResult.autoRemediationItems,
      integrations,
      environment,
      dryRun: false,
      outputDir
    });

    artifacts.push(...autoRemediationResult.artifacts);

    ctx.log('info', `Automated remediation complete - ${autoRemediationResult.successful} successful, ${autoRemediationResult.failed} failed`);

    // Quality Gate: Auto-remediation results review
    await ctx.breakpoint({
      question: `Automated remediation complete. ${autoRemediationResult.successful} successful fixes, ${autoRemediationResult.failed} failures. Review auto-remediation results?`,
      title: 'Automated Remediation Review',
      context: {
        runId: ctx.runId,
        autoRemediation: {
          attempted: autoRemediationResult.attempted,
          successful: autoRemediationResult.successful,
          failed: autoRemediationResult.failed,
          successRate: autoRemediationResult.successRate,
          remediationTypes: autoRemediationResult.remediationTypes
        },
        successfulRemediations: autoRemediationResult.successfulList.slice(0, 10),
        failedRemediations: autoRemediationResult.failedList,
        files: autoRemediationResult.artifacts.map(a => ({ path: a.path, format: a.format || 'json', label: a.label }))
      }
    });
  }

  // ============================================================================
  // PHASE 7: REMEDIATION PROGRESS TRACKING
  // ============================================================================

  ctx.log('info', 'Phase 7: Tracking remediation progress and SLA compliance');

  const trackingResult = await ctx.task(trackRemediationProgressTask, {
    projectName,
    remediationTickets: assignmentResult.remediationTickets,
    slaTargets,
    integrations,
    outputDir
  });

  artifacts.push(...trackingResult.artifacts);

  ctx.log('info', `Remediation tracking updated - ${trackingResult.inProgress} in progress, ${trackingResult.completed} completed, ${trackingResult.slaBreaches} SLA breaches`);

  // ============================================================================
  // PHASE 8: VERIFICATION AND VALIDATION
  // ============================================================================

  ctx.log('info', 'Phase 8: Verifying remediation effectiveness');

  const verificationResult = await ctx.task(verifyRemediationTask, {
    projectName,
    remediatedVulnerabilities: trackingResult.completedRemediations,
    assets: assetInventoryResult.assets,
    scanTypes,
    integrations,
    outputDir
  });

  artifacts.push(...verificationResult.artifacts);

  ctx.log('info', `Remediation verification complete - ${verificationResult.verified} verified, ${verificationResult.reopen} need reopening`);

  // Quality Gate: Verification review
  await ctx.breakpoint({
    question: `Remediation verification complete. ${verificationResult.verified} fixes verified, ${verificationResult.reopen} need reopening. Review verification results?`,
    title: 'Remediation Verification Review',
    context: {
      runId: ctx.runId,
      verification: {
        totalChecked: verificationResult.totalChecked,
        verified: verificationResult.verified,
        reopen: verificationResult.reopen,
        verificationRate: verificationResult.verificationRate
      },
      reopenedVulnerabilities: verificationResult.reopenedList,
      files: verificationResult.artifacts.map(a => ({ path: a.path, format: a.format || 'json', label: a.label }))
    }
  });

  // ============================================================================
  // PHASE 9: CALCULATE MTTD AND MTTR METRICS
  // ============================================================================

  ctx.log('info', 'Phase 9: Calculating vulnerability management metrics (MTTD, MTTR)');

  const metricsResult = await ctx.task(calculateMetricsTask, {
    projectName,
    vulnerabilities: prioritizationResult.vulnerabilitiesList,
    remediationTickets: assignmentResult.remediationTickets,
    verificationResults: verificationResult,
    slaTargets,
    outputDir
  });

  artifacts.push(...metricsResult.artifacts);
  Object.assign(metrics, metricsResult.metrics);

  ctx.log('info', `Metrics calculation complete - MTTD: ${metrics.mttd} hours, MTTR: ${metrics.mttr} hours`);

  // ============================================================================
  // PHASE 10: TREND ANALYSIS AND REPORTING
  // ============================================================================

  ctx.log('info', 'Phase 10: Analyzing trends and generating reports');

  const trendAnalysisResult = await ctx.task(analyzeTrendsTask, {
    projectName,
    vulnerabilities: prioritizationResult.vulnerabilitiesList,
    metrics,
    historicalData: true,
    complianceFrameworks,
    portfolioView,
    outputDir
  });

  artifacts.push(...trendAnalysisResult.artifacts);

  ctx.log('info', `Trend analysis complete - ${trendAnalysisResult.trendsIdentified} trends identified`);

  // ============================================================================
  // PHASE 11: COMPLIANCE REPORTING
  // ============================================================================

  if (complianceFrameworks.length > 0) {
    ctx.log('info', 'Phase 11: Generating compliance reports');

    const complianceResult = await ctx.task(generateComplianceReportsTask, {
      projectName,
      vulnerabilities: prioritizationResult.vulnerabilitiesList,
      metrics,
      complianceFrameworks,
      remediationStatus: trackingResult,
      outputDir
    });

    artifacts.push(...complianceResult.artifacts);

    ctx.log('info', `Compliance reporting complete - ${complianceResult.reportsGenerated} compliance reports generated`);

    // Quality Gate: Compliance review
    await ctx.breakpoint({
      question: `Compliance reports generated for ${complianceFrameworks.join(', ')}. ${complianceResult.complianceGaps} gaps identified. Review compliance status?`,
      title: 'Compliance Reporting Review',
      context: {
        runId: ctx.runId,
        compliance: {
          frameworks: complianceFrameworks,
          reportsGenerated: complianceResult.reportsGenerated,
          complianceGaps: complianceResult.complianceGaps,
          complianceScore: complianceResult.complianceScore
        },
        complianceStatus: complianceResult.complianceStatus,
        files: complianceResult.artifacts.map(a => ({ path: a.path, format: a.format || 'json', label: a.label }))
      }
    });
  }

  // ============================================================================
  // PHASE 12: GENERATE COMPREHENSIVE DOCUMENTATION
  // ============================================================================

  ctx.log('info', 'Phase 12: Generating vulnerability management documentation');

  const documentationResult = await ctx.task(generateDocumentationTask, {
    projectName,
    assetInventoryResult,
    scanningResult,
    validationResult,
    prioritizationResult,
    assignmentResult,
    trackingResult,
    verificationResult,
    metricsResult,
    trendAnalysisResult,
    complianceFrameworks,
    outputDir
  });

  artifacts.push(...documentationResult.artifacts);

  ctx.log('info', `Documentation generated - Report: ${documentationResult.reportPath}`);

  // ============================================================================
  // PHASE 13: CALCULATE VULNERABILITY MANAGEMENT SCORE
  // ============================================================================

  ctx.log('info', 'Phase 13: Calculating vulnerability management effectiveness score');

  const scoringResult = await ctx.task(calculateVulnerabilityScoreTask, {
    projectName,
    metrics,
    scanningResult,
    prioritizationResult,
    remediationStatus: trackingResult,
    verificationResult,
    slaTargets,
    outputDir
  });

  vulnerabilityScore = scoringResult.vulnerabilityScore;
  artifacts.push(...scoringResult.artifacts);

  ctx.log('info', `Vulnerability Management Score: ${vulnerabilityScore}/100`);

  // Final Breakpoint: Vulnerability management cycle complete
  await ctx.breakpoint({
    question: `Vulnerability Management Lifecycle Complete for ${projectName}. Score: ${vulnerabilityScore}/100. MTTD: ${metrics.mttd}h, MTTR: ${metrics.mttr}h. Review final results?`,
    title: 'Final Vulnerability Management Review',
    context: {
      runId: ctx.runId,
      summary: {
        projectName,
        vulnerabilityScore,
        totalVulnerabilities: metrics.totalVulnerabilities,
        criticalCount: metrics.criticalCount,
        highCount: metrics.highCount,
        openCount: metrics.openCount,
        remediatedCount: metrics.remediatedCount,
        mttd: metrics.mttd,
        mttr: metrics.mttr,
        slaCompliance: trackingResult.slaComplianceRate
      },
      breakdown: {
        scanning: {
          scannersUsed: scanningResult.scannersUsed.length,
          scanCoverage: scanningResult.scanCoverage,
          totalFindings: scanningResult.totalFindings
        },
        prioritization: {
          method: prioritizationMethod,
          cisaKevMatches: prioritizationResult.cisaKevMatches,
          avgCvssScore: prioritizationResult.avgCvssScore,
          avgEpssScore: prioritizationResult.avgEpssScore
        },
        remediation: {
          ticketsCreated: assignmentResult.ticketsCreated,
          inProgress: trackingResult.inProgress,
          completed: trackingResult.completed,
          slaBreaches: trackingResult.slaBreaches
        },
        verification: {
          verified: verificationResult.verified,
          verificationRate: verificationResult.verificationRate
        }
      },
      verdict: scoringResult.verdict,
      recommendation: scoringResult.recommendation,
      files: [
        { path: documentationResult.reportPath, format: 'markdown', label: 'Vulnerability Management Report' },
        { path: scoringResult.summaryPath, format: 'json', label: 'Vulnerability Score Summary' },
        { path: metricsResult.metricsReportPath, format: 'json', label: 'MTTD/MTTR Metrics Report' }
      ]
    }
  });

  const endTime = ctx.now();
  const duration = endTime - startTime;

  return {
    success: true,
    projectName,
    environment,
    vulnerabilityScore,
    vulnerabilities: {
      total: metrics.totalVulnerabilities,
      critical: metrics.criticalCount,
      high: metrics.highCount,
      medium: metrics.mediumCount,
      low: metrics.lowCount,
      open: metrics.openCount,
      remediated: metrics.remediatedCount,
      falsePositives: metrics.falsePositiveCount
    },
    metrics: {
      mttd: metrics.mttd,
      mttr: metrics.mttr,
      mttrBySeverity: metricsResult.mttrBySeverity,
      slaCompliance: trackingResult.slaComplianceRate,
      remediationRate: metricsResult.remediationRate,
      reopenRate: verificationResult.reopenRate
    },
    scanning: {
      totalFindings: scanningResult.totalFindings,
      scannersUsed: scanningResult.scannersUsed,
      scanCoverage: scanningResult.scanCoverage,
      lastScanDate: scanningResult.lastScanDate
    },
    prioritization: {
      method: prioritizationMethod,
      cisaKevMatches: prioritizationResult.cisaKevMatches,
      avgCvssScore: prioritizationResult.avgCvssScore,
      avgEpssScore: prioritizationResult.avgEpssScore,
      criticalPriority: prioritizationResult.criticalPriority,
      highPriority: prioritizationResult.highPriority
    },
    remediationStatus: {
      ticketsCreated: assignmentResult.ticketsCreated,
      inProgress: trackingResult.inProgress,
      completed: trackingResult.completed,
      slaBreaches: trackingResult.slaBreaches,
      slaComplianceRate: trackingResult.slaComplianceRate,
      autoRemediationSuccessRate: assignmentResult.autoRemediationQueued > 0 ?
        (trackingResult.autoRemediationSuccessful / assignmentResult.autoRemediationQueued * 100) : 0
    },
    verification: {
      totalChecked: verificationResult.totalChecked,
      verified: verificationResult.verified,
      reopened: verificationResult.reopen,
      verificationRate: verificationResult.verificationRate
    },
    trends: {
      trendsIdentified: trendAnalysisResult.trendsIdentified,
      vulnerabilityTrend: trendAnalysisResult.vulnerabilityTrend,
      remediationTrend: trendAnalysisResult.remediationTrend
    },
    artifacts,
    documentation: {
      reportPath: documentationResult.reportPath,
      summaryPath: scoringResult.summaryPath,
      metricsReportPath: metricsResult.metricsReportPath
    },
    duration,
    metadata: {
      processId: 'specializations/security-compliance/vulnerability-management',
      processSlug: 'vulnerability-management',
      category: 'security-compliance',
      specializationSlug: 'security-compliance',
      timestamp: startTime,
      assetScope,
      scanTypes,
      prioritizationMethod,
      outputDir
    }
  };
}

// ============================================================================
// TASK DEFINITIONS
// ============================================================================

// Phase 1: Discover Assets
export const discoverAssetsTask = defineTask('discover-assets', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 1: Discover and Inventory Assets - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Security Asset Management Specialist',
      task: 'Discover and inventory all assets within scope for vulnerability management',
      context: {
        projectName: args.projectName,
        assetScope: args.assetScope,
        environment: args.environment,
        portfolioView: args.portfolioView,
        outputDir: args.outputDir
      },
      instructions: [
        '1. Discover all assets in scope based on assetScope configuration:',
        '   - Applications: Web apps, mobile apps, APIs, microservices',
        '   - Infrastructure: Servers, VMs, cloud resources, network devices',
        '   - Containers: Docker images, container registries, running containers',
        '   - Dependencies: Third-party libraries, open source packages, SDKs',
        '2. For each asset, collect:',
        '   - Asset name and identifier',
        '   - Asset type and technology stack',
        '   - Ownership and responsible team',
        '   - Business criticality (critical, high, medium, low)',
        '   - Environment (production, staging, development)',
        '   - Version information',
        '   - Network location and endpoints',
        '3. Build asset relationships and dependencies',
        '4. Tag assets with relevant metadata',
        '5. Identify assets requiring special scanning configurations',
        '6. Calculate asset coverage percentage',
        '7. Create asset inventory database/spreadsheet',
        '8. Generate asset topology diagram (if portfolioView enabled)',
        '9. Document asset discovery methodology'
      ],
      outputFormat: 'JSON object with asset inventory'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'totalAssets', 'assets', 'assetTypes', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        totalAssets: { type: 'number' },
        assets: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              id: { type: 'string' },
              name: { type: 'string' },
              type: { type: 'string' },
              technology: { type: 'string' },
              owner: { type: 'string' },
              criticality: { type: 'string', enum: ['critical', 'high', 'medium', 'low'] },
              environment: { type: 'string' },
              version: { type: 'string' }
            }
          }
        },
        assetTypes: { type: 'array', items: { type: 'string' } },
        assetBreakdown: {
          type: 'object',
          properties: {
            applications: { type: 'number' },
            infrastructure: { type: 'number' },
            containers: { type: 'number' },
            dependencies: { type: 'number' }
          }
        },
        applications: { type: 'array', items: { type: 'object' } },
        infrastructure: { type: 'array', items: { type: 'object' } },
        containers: { type: 'array', items: { type: 'object' } },
        dependencies: { type: 'array', items: { type: 'object' } },
        assetCoverage: { type: 'number', description: 'Percentage of known assets discovered' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'asset-discovery']
}));

// Phase 2: Execute Vulnerability Scanning
export const executeVulnerabilityScanningTask = defineTask('execute-vulnerability-scanning', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 2: Execute Vulnerability Scanning - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Vulnerability Scanning Engineer',
      task: 'Execute comprehensive vulnerability scanning across all assets',
      context: {
        projectName: args.projectName,
        assets: args.assets,
        scanTypes: args.scanTypes,
        integrations: args.integrations,
        continuousScanning: args.continuousScanning,
        outputDir: args.outputDir
      },
      instructions: [
        '1. Execute vulnerability scans based on scanTypes:',
        '   - SAST: Static Application Security Testing (code analysis)',
        '   - DAST: Dynamic Application Security Testing (runtime analysis)',
        '   - SCA: Software Composition Analysis (dependency scanning)',
        '   - Container Scanning: Container image vulnerability scanning',
        '   - Infrastructure Scanning: Infrastructure and configuration scanning',
        '   - Network Scanning: Network vulnerability scanning',
        '2. For each scanner type, use configured integrations:',
        '   - Snyk for SCA and container scanning',
        '   - Trivy for container and IaC scanning',
        '   - SonarQube for SAST',
        '   - Nessus for infrastructure scanning',
        '   - OWASP ZAP or Burp for DAST',
        '3. Configure scan parameters:',
        '   - Scan depth and thoroughness',
        '   - Authentication credentials (for authenticated scans)',
        '   - Scan scheduling (if continuous scanning enabled)',
        '   - Scan exclusions and scope',
        '4. Collect scan results from all scanners',
        '5. Normalize findings to common vulnerability format:',
        '   - CVE ID (if applicable)',
        '   - CWE ID',
        '   - Vulnerability title and description',
        '   - Affected asset and component',
        '   - Severity rating',
        '   - CVSS score',
        '   - Discovery date',
        '6. Calculate scan coverage metrics',
        '7. Generate consolidated scan report',
        '8. Set up continuous scanning schedule (if enabled)'
      ],
      outputFormat: 'JSON object with scan results'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'totalFindings', 'vulnerabilities', 'scannersUsed', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        totalFindings: { type: 'number' },
        criticalFindings: { type: 'number' },
        highFindings: { type: 'number' },
        mediumFindings: { type: 'number' },
        lowFindings: { type: 'number' },
        vulnerabilities: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              id: { type: 'string' },
              cveId: { type: 'string' },
              cweId: { type: 'string' },
              title: { type: 'string' },
              description: { type: 'string' },
              severity: { type: 'string' },
              cvss: { type: 'number' },
              asset: { type: 'string' },
              component: { type: 'string' },
              discoveryDate: { type: 'string' },
              scanner: { type: 'string' }
            }
          }
        },
        scannersUsed: { type: 'array', items: { type: 'string' } },
        scanCoverage: { type: 'number', description: 'Percentage of assets scanned' },
        lastScanDate: { type: 'string' },
        continuousScanningEnabled: { type: 'boolean' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'scanning']
}));

// Phase 3: Validate and Deduplicate
export const validateAndDeduplicateTask = defineTask('validate-deduplicate', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 3: Validate and Deduplicate Vulnerabilities - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Vulnerability Validation Analyst',
      task: 'Validate findings, remove duplicates, and identify false positives',
      context: {
        projectName: args.projectName,
        vulnerabilities: args.vulnerabilities,
        falsePositiveManagement: args.falsePositiveManagement,
        historicalData: args.historicalData,
        outputDir: args.outputDir
      },
      instructions: [
        '1. Validate each vulnerability finding:',
        '   - Confirm vulnerability exists in the target asset',
        '   - Verify the affected version',
        '   - Check exploitability conditions',
        '   - Assess actual impact in the context',
        '2. Identify and remove duplicate findings:',
        '   - Same CVE reported by multiple scanners',
        '   - Same vulnerability in different components',
        '   - Use vulnerability fingerprinting for deduplication',
        '3. False positive management (if enabled):',
        '   - Check against historical false positive database',
        '   - Analyze context and applicability',
        '   - Flag suspected false positives for review',
        '   - Document false positive reasoning',
        '4. Consolidate vulnerability information:',
        '   - Merge data from multiple scanners',
        '   - Enrich with CVE database information',
        '   - Add vendor advisories and patches',
        '5. Calculate confidence score for each finding',
        '6. Tag vulnerabilities with validation status',
        '7. Generate validation report',
        '8. Update false positive database'
      ],
      outputFormat: 'JSON object with validated vulnerabilities'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'validatedVulnerabilities', 'duplicatesRemoved', 'falsePositives', 'validatedVulnerabilitiesList', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        validatedVulnerabilities: { type: 'number' },
        duplicatesRemoved: { type: 'number' },
        falsePositives: { type: 'number' },
        validatedVulnerabilitiesList: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              id: { type: 'string' },
              cveId: { type: 'string' },
              title: { type: 'string' },
              severity: { type: 'string' },
              cvss: { type: 'number' },
              asset: { type: 'string' },
              validated: { type: 'boolean' },
              confidenceScore: { type: 'number' }
            }
          }
        },
        validationRate: { type: 'number', description: 'Percentage of findings validated' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'validation']
}));

// Phase 4: Prioritize Vulnerabilities
export const prioritizeVulnerabilitiesTask = defineTask('prioritize-vulnerabilities', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 4: Prioritize Vulnerabilities (CVSS/EPSS) - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Vulnerability Risk Assessment Specialist',
      task: 'Perform risk-based prioritization using CVSS, EPSS, and business context',
      context: {
        projectName: args.projectName,
        vulnerabilities: args.vulnerabilities,
        prioritizationMethod: args.prioritizationMethod,
        riskThreshold: args.riskThreshold,
        complianceFrameworks: args.complianceFrameworks,
        cisaKevCheck: args.cisaKevCheck,
        businessContext: args.businessContext,
        outputDir: args.outputDir
      },
      instructions: [
        '1. For each vulnerability, collect scoring data:',
        '   - CVSS v3.1 score (if available) - measures severity',
        '   - EPSS score - measures probability of exploitation',
        '   - CISA KEV status - check if in Known Exploited Vulnerabilities catalog',
        '   - Exploit availability (public exploits, exploit maturity)',
        '2. Calculate composite priority score based on prioritizationMethod:',
        '   - cvss: Use CVSS score only',
        '   - epss: Use EPSS probability only',
        '   - cvss-epss: Weighted combination (CVSS 60%, EPSS 40%)',
        '   - custom: Include business context factors',
        '3. Apply business context multipliers (if enabled):',
        '   - Asset criticality (critical assets get higher priority)',
        '   - Internet-facing exposure (external assets prioritized)',
        '   - Data sensitivity (assets with PII/financial data)',
        '   - Compensating controls (reduce priority if mitigations exist)',
        '4. Apply compliance framework requirements:',
        '   - Flag vulnerabilities required for compliance',
        '   - Apply framework-specific prioritization rules',
        '5. Check CISA KEV catalog (if enabled):',
        '   - Mark vulnerabilities in KEV as critical priority',
        '   - Set aggressive remediation timelines for KEV items',
        '6. Filter by risk threshold (minimum severity to track)',
        '7. Rank vulnerabilities by final priority score',
        '8. Assign remediation timeline recommendation',
        '9. Generate prioritization report with scoring breakdown',
        '10. Create heat map visualization of vulnerabilities'
      ],
      outputFormat: 'JSON object with prioritized vulnerabilities'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'prioritizedVulnerabilities', 'vulnerabilitiesList', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        prioritizedVulnerabilities: { type: 'number' },
        criticalPriority: { type: 'number' },
        highPriority: { type: 'number' },
        mediumPriority: { type: 'number' },
        lowPriority: { type: 'number' },
        cisaKevMatches: { type: 'number', description: 'Vulnerabilities in CISA KEV catalog' },
        avgCvssScore: { type: 'number' },
        avgEpssScore: { type: 'number' },
        vulnerabilitiesList: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              id: { type: 'string' },
              cveId: { type: 'string' },
              title: { type: 'string' },
              severity: { type: 'string' },
              cvss: { type: 'number' },
              epss: { type: 'number' },
              priorityScore: { type: 'number' },
              priority: { type: 'string', enum: ['critical', 'high', 'medium', 'low'] },
              cisaKev: { type: 'boolean' },
              exploitAvailable: { type: 'boolean' },
              asset: { type: 'string' },
              recommendedTimeline: { type: 'string' }
            }
          }
        },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'prioritization']
}));

// Phase 5: Assign Remediation
export const assignRemediationTask = defineTask('assign-remediation', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 5: Assign Remediation and Create Tickets - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Vulnerability Remediation Coordinator',
      task: 'Assign vulnerabilities for remediation and create tracking tickets',
      context: {
        projectName: args.projectName,
        vulnerabilities: args.vulnerabilities,
        slaTargets: args.slaTargets,
        integrations: args.integrations,
        autoRemediation: args.autoRemediation,
        outputDir: args.outputDir
      },
      instructions: [
        '1. For each vulnerability, determine remediation approach:',
        '   - Patch/Update: Apply vendor patch or update',
        '   - Configuration Change: Modify configuration',
        '   - Code Fix: Modify application code',
        '   - Compensating Control: Apply temporary mitigation',
        '   - Accept Risk: Document acceptance (low priority items)',
        '2. Identify auto-remediation candidates (if enabled):',
        '   - Dependency updates (automated version bumps)',
        '   - Configuration fixes (automated config changes)',
        '   - Low-risk changes with automated tests',
        '3. Assign to responsible teams based on:',
        '   - Asset ownership',
        '   - Vulnerability type (infrastructure, application, dependency)',
        '   - Team expertise and capacity',
        '4. Create remediation tickets in ticketing system:',
        '   - Jira, ServiceNow, GitHub Issues, or Linear',
        '   - Include vulnerability details, impact, and fix guidance',
        '   - Add links to CVE database, vendor advisories',
        '   - Attach remediation instructions and testing steps',
        '5. Set SLA due dates based on severity:',
        '   - Critical: 24 hours (default)',
        '   - High: 7 days (default)',
        '   - Medium: 30 days (default)',
        '   - Low: 90 days (default)',
        '6. Tag tickets with metadata (CVE, asset, severity, team)',
        '7. Configure notifications to assigned teams',
        '8. Queue auto-remediation items for execution',
        '9. Generate remediation plan document'
      ],
      outputFormat: 'JSON object with remediation assignments'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'ticketsCreated', 'remediationTickets', 'teamsAssigned', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        ticketsCreated: { type: 'number' },
        teamsAssigned: { type: 'number' },
        autoRemediationQueued: { type: 'number' },
        criticalAssignments: { type: 'number' },
        highAssignments: { type: 'number' },
        potentialSlaBreaches: { type: 'number', description: 'Tickets at risk of SLA breach' },
        remediationTickets: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              ticketId: { type: 'string' },
              vulnerabilityId: { type: 'string' },
              cveId: { type: 'string' },
              title: { type: 'string' },
              severity: { type: 'string' },
              assignedTeam: { type: 'string' },
              dueDate: { type: 'string' },
              remediationApproach: { type: 'string' },
              status: { type: 'string' }
            }
          }
        },
        autoRemediationItems: { type: 'array', items: { type: 'object' } },
        remediationBreakdown: {
          type: 'object',
          properties: {
            patch: { type: 'number' },
            configuration: { type: 'number' },
            codefix: { type: 'number' },
            compensating: { type: 'number' },
            acceptRisk: { type: 'number' }
          }
        },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'assignment']
}));

// Phase 6: Execute Auto Remediation
export const executeAutoRemediationTask = defineTask('execute-auto-remediation', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 6: Execute Automated Remediation - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Automated Remediation Engineer',
      task: 'Execute automated remediation for eligible vulnerabilities',
      context: {
        projectName: args.projectName,
        vulnerabilities: args.vulnerabilities,
        integrations: args.integrations,
        environment: args.environment,
        dryRun: args.dryRun,
        outputDir: args.outputDir
      },
      instructions: [
        '1. Review auto-remediation queue for eligible items',
        '2. For each vulnerability, execute remediation:',
        '   - Dependency Updates:',
        '     * Update package.json, requirements.txt, pom.xml, etc.',
        '     * Run dependency manager (npm, pip, maven)',
        '     * Create PR with automated tests',
        '   - Configuration Fixes:',
        '     * Apply secure configuration changes',
        '     * Update IaC templates (Terraform, CloudFormation)',
        '     * Deploy configuration changes',
        '   - Container Image Updates:',
        '     * Rebuild images with updated base images',
        '     * Push to container registry',
        '     * Update deployment manifests',
        '3. Run automated tests after each fix:',
        '   - Unit tests',
        '   - Integration tests',
        '   - Security regression tests',
        '4. Verify fix effectiveness with re-scan',
        '5. If tests pass and vulnerability resolved:',
        '   - Create pull request (for code changes)',
        '   - Deploy (for infrastructure changes)',
        '   - Update ticket status to "Auto-Remediated"',
        '6. If tests fail or vulnerability persists:',
        '   - Roll back changes',
        '   - Add to manual remediation queue',
        '   - Notify assigned team',
        '7. Track success and failure metrics',
        '8. Generate auto-remediation report'
      ],
      outputFormat: 'JSON object with auto-remediation results'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'attempted', 'successful', 'failed', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        attempted: { type: 'number' },
        successful: { type: 'number' },
        failed: { type: 'number' },
        successRate: { type: 'number' },
        remediationTypes: {
          type: 'object',
          properties: {
            dependencyUpdates: { type: 'number' },
            configurationFixes: { type: 'number' },
            containerUpdates: { type: 'number' }
          }
        },
        successfulList: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              vulnerabilityId: { type: 'string' },
              cveId: { type: 'string' },
              remediationType: { type: 'string' },
              fixApplied: { type: 'string' },
              testsPass: { type: 'boolean' }
            }
          }
        },
        failedList: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              vulnerabilityId: { type: 'string' },
              cveId: { type: 'string' },
              reason: { type: 'string' }
            }
          }
        },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'auto-remediation']
}));

// Phase 7: Track Remediation Progress
export const trackRemediationProgressTask = defineTask('track-remediation-progress', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 7: Track Remediation Progress - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Vulnerability Remediation Tracker',
      task: 'Track remediation progress and monitor SLA compliance',
      context: {
        projectName: args.projectName,
        remediationTickets: args.remediationTickets,
        slaTargets: args.slaTargets,
        integrations: args.integrations,
        outputDir: args.outputDir
      },
      instructions: [
        '1. Query ticketing system for current status of all tickets',
        '2. Update remediation tracking database with:',
        '   - Current status (open, in-progress, resolved, closed)',
        '   - Assigned owner',
        '   - Last update timestamp',
        '   - Comments and progress notes',
        '3. Calculate time metrics for each ticket:',
        '   - Time open (current time - discovery date)',
        '   - Time to assignment',
        '   - Time in remediation',
        '   - Time to resolution (for completed)',
        '4. Check SLA compliance:',
        '   - Compare time open against SLA target for severity',
        '   - Identify tickets approaching SLA deadline',
        '   - Flag SLA breaches',
        '5. Calculate aggregate metrics:',
        '   - Total tickets by status',
        '   - SLA compliance rate by severity',
        '   - Average time in each status',
        '6. Identify bottlenecks:',
        '   - Teams with highest backlog',
        '   - Oldest open tickets',
        '   - Tickets stuck in one status',
        '7. Generate progress dashboard data',
        '8. Send SLA breach notifications',
        '9. Create remediation progress report'
      ],
      outputFormat: 'JSON object with remediation tracking status'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'inProgress', 'completed', 'slaBreaches', 'slaComplianceRate', 'completedRemediations', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        totalTracked: { type: 'number' },
        open: { type: 'number' },
        inProgress: { type: 'number' },
        completed: { type: 'number' },
        closed: { type: 'number' },
        slaBreaches: { type: 'number' },
        slaComplianceRate: { type: 'number', description: 'Percentage of tickets meeting SLA' },
        slaComplianceBySeverity: {
          type: 'object',
          properties: {
            critical: { type: 'number' },
            high: { type: 'number' },
            medium: { type: 'number' },
            low: { type: 'number' }
          }
        },
        avgTimeToRemediate: { type: 'number', description: 'Average days to remediate' },
        completedRemediations: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              ticketId: { type: 'string' },
              vulnerabilityId: { type: 'string' },
              completedDate: { type: 'string' },
              timeToRemediate: { type: 'number' }
            }
          }
        },
        autoRemediationSuccessful: { type: 'number' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'tracking']
}));

// Phase 8: Verify Remediation
export const verifyRemediationTask = defineTask('verify-remediation', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 8: Verify Remediation Effectiveness - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Vulnerability Verification Specialist',
      task: 'Verify that remediation efforts have successfully resolved vulnerabilities',
      context: {
        projectName: args.projectName,
        remediatedVulnerabilities: args.remediatedVulnerabilities,
        assets: args.assets,
        scanTypes: args.scanTypes,
        integrations: args.integrations,
        outputDir: args.outputDir
      },
      instructions: [
        '1. For each completed remediation, perform verification:',
        '   - Re-scan the affected asset/component',
        '   - Check if vulnerability still exists',
        '   - Verify the specific fix was applied correctly',
        '2. Verification methods by vulnerability type:',
        '   - Dependency vulnerabilities: Check package versions',
        '   - Configuration issues: Verify configuration values',
        '   - Code vulnerabilities: Review code changes and run SAST',
        '   - Infrastructure: Run compliance and security scans',
        '3. Test fix effectiveness:',
        '   - Attempt to reproduce the vulnerability',
        '   - Run security regression tests',
        '   - Verify no new issues were introduced',
        '4. Verification outcomes:',
        '   - Verified: Vulnerability no longer exists, fix effective',
        '   - Partial: Vulnerability reduced but not eliminated',
        '   - Failed: Vulnerability still exists',
        '   - Reopen: Vulnerability resurfaces or incomplete fix',
        '5. For failed verifications:',
        '   - Document why remediation was ineffective',
        '   - Reopen ticket with additional context',
        '   - Escalate if critical/high severity',
        '6. Update vulnerability status in tracking system',
        '7. Calculate verification success rate',
        '8. Generate verification report with evidence',
        '9. Archive verified vulnerabilities'
      ],
      outputFormat: 'JSON object with verification results'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'totalChecked', 'verified', 'reopen', 'verificationRate', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        totalChecked: { type: 'number' },
        verified: { type: 'number', description: 'Successfully verified as fixed' },
        partial: { type: 'number', description: 'Partially fixed' },
        failed: { type: 'number', description: 'Verification failed' },
        reopen: { type: 'number', description: 'Need to reopen tickets' },
        verificationRate: { type: 'number', description: 'Percentage successfully verified' },
        reopenRate: { type: 'number', description: 'Percentage needing reopening' },
        verifiedList: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              vulnerabilityId: { type: 'string' },
              cveId: { type: 'string' },
              verificationDate: { type: 'string' },
              outcome: { type: 'string' }
            }
          }
        },
        reopenedList: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              vulnerabilityId: { type: 'string' },
              cveId: { type: 'string' },
              reason: { type: 'string' }
            }
          }
        },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'verification']
}));

// Phase 9: Calculate Metrics
export const calculateMetricsTask = defineTask('calculate-metrics', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 9: Calculate MTTD and MTTR Metrics - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Security Metrics Analyst',
      task: 'Calculate vulnerability management metrics including MTTD and MTTR',
      context: {
        projectName: args.projectName,
        vulnerabilities: args.vulnerabilities,
        remediationTickets: args.remediationTickets,
        verificationResults: args.verificationResults,
        slaTargets: args.slaTargets,
        outputDir: args.outputDir
      },
      instructions: [
        '1. Calculate Mean Time To Detect (MTTD):',
        '   - Time from vulnerability introduction to discovery',
        '   - Average across all discovered vulnerabilities',
        '   - Break down by severity and asset type',
        '2. Calculate Mean Time To Remediate (MTTR):',
        '   - Time from discovery to verified fix',
        '   - Average across all remediated vulnerabilities',
        '   - Break down by severity:',
        '     * Critical MTTR',
        '     * High MTTR',
        '     * Medium MTTR',
        '     * Low MTTR',
        '3. Calculate additional metrics:',
        '   - Vulnerability discovery rate (new vulns per week/month)',
        '   - Remediation rate (vulns fixed per week/month)',
        '   - Backlog size and age',
        '   - SLA compliance rate by severity',
        '   - False positive rate',
        '   - Re-open rate',
        '   - Time to assignment',
        '   - Time in remediation',
        '4. Calculate velocity metrics:',
        '   - Vulnerability remediation velocity (trend)',
        '   - Backlog burn rate',
        '5. Compare against industry benchmarks:',
        '   - MTTD benchmark: 7 days (good), 30 days (average)',
        '   - MTTR benchmark: Critical 1 day, High 7 days, Medium 30 days',
        '6. Calculate risk exposure metrics:',
        '   - Total risk score (sum of CVSS scores)',
        '   - Open critical/high vulnerability days',
        '7. Generate metrics dashboard JSON',
        '8. Create metrics trend charts',
        '9. Generate comprehensive metrics report'
      ],
      outputFormat: 'JSON object with vulnerability metrics'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'metrics', 'metricsReportPath', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        metrics: {
          type: 'object',
          properties: {
            mttd: { type: 'number', description: 'Mean Time To Detect in hours' },
            mttr: { type: 'number', description: 'Mean Time To Remediate in hours' },
            totalVulnerabilities: { type: 'number' },
            criticalCount: { type: 'number' },
            highCount: { type: 'number' },
            mediumCount: { type: 'number' },
            lowCount: { type: 'number' },
            openCount: { type: 'number' },
            remediatedCount: { type: 'number' },
            falsePositiveCount: { type: 'number' }
          }
        },
        mttrBySeverity: {
          type: 'object',
          properties: {
            critical: { type: 'number', description: 'MTTR for critical in hours' },
            high: { type: 'number', description: 'MTTR for high in hours' },
            medium: { type: 'number', description: 'MTTR for medium in hours' },
            low: { type: 'number', description: 'MTTR for low in hours' }
          }
        },
        remediationRate: { type: 'number', description: 'Vulnerabilities remediated per week' },
        discoveryRate: { type: 'number', description: 'Vulnerabilities discovered per week' },
        backlogSize: { type: 'number' },
        avgBacklogAge: { type: 'number', description: 'Average age of open vulnerabilities in days' },
        riskExposure: {
          type: 'object',
          properties: {
            totalRiskScore: { type: 'number' },
            criticalExposureDays: { type: 'number' },
            highExposureDays: { type: 'number' }
          }
        },
        benchmarkComparison: {
          type: 'object',
          properties: {
            mttdVsBenchmark: { type: 'string' },
            mttrVsBenchmark: { type: 'string' }
          }
        },
        metricsReportPath: { type: 'string' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'metrics']
}));

// Phase 10: Analyze Trends
export const analyzeTrendsTask = defineTask('analyze-trends', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 10: Analyze Vulnerability Trends - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Security Trend Analyst',
      task: 'Analyze vulnerability trends and generate insights',
      context: {
        projectName: args.projectName,
        vulnerabilities: args.vulnerabilities,
        metrics: args.metrics,
        historicalData: args.historicalData,
        complianceFrameworks: args.complianceFrameworks,
        portfolioView: args.portfolioView,
        outputDir: args.outputDir
      },
      instructions: [
        '1. Analyze vulnerability trends over time:',
        '   - New vulnerabilities discovered (trend up/down/stable)',
        '   - Remediation velocity (trend up/down/stable)',
        '   - Backlog size trend',
        '   - MTTD/MTTR trends',
        '2. Identify vulnerability patterns:',
        '   - Most common vulnerability types (CWE)',
        '   - Most affected assets/technologies',
        '   - Most problematic dependencies',
        '   - Recurring vulnerabilities',
        '3. Analyze by asset type:',
        '   - Applications vulnerability density',
        '   - Infrastructure vulnerability density',
        '   - Container vulnerability density',
        '   - Dependency vulnerability density',
        '4. Analyze by team performance:',
        '   - Teams with fastest MTTR',
        '   - Teams with highest backlog',
        '   - Teams at risk of SLA breaches',
        '5. Identify risk hotspots:',
        '   - Assets with most critical vulnerabilities',
        '   - Components with highest risk exposure',
        '   - Technologies with poor security posture',
        '6. Compare against previous periods:',
        '   - Month-over-month changes',
        '   - Quarter-over-quarter changes',
        '   - Year-over-year changes',
        '7. Generate predictive insights:',
        '   - Projected backlog size',
        '   - Capacity planning recommendations',
        '   - Risk forecast',
        '8. Create trend visualizations',
        '9. Generate trend analysis report with actionable recommendations'
      ],
      outputFormat: 'JSON object with trend analysis'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'trendsIdentified', 'vulnerabilityTrend', 'remediationTrend', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        trendsIdentified: { type: 'number' },
        vulnerabilityTrend: { type: 'string', enum: ['increasing', 'decreasing', 'stable'] },
        remediationTrend: { type: 'string', enum: ['improving', 'declining', 'stable'] },
        commonVulnerabilityTypes: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              cweId: { type: 'string' },
              cweName: { type: 'string' },
              count: { type: 'number' },
              percentage: { type: 'number' }
            }
          }
        },
        riskHotspots: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              asset: { type: 'string' },
              criticalCount: { type: 'number' },
              highCount: { type: 'number' },
              riskScore: { type: 'number' }
            }
          }
        },
        performanceByTeam: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              team: { type: 'string' },
              avgMttr: { type: 'number' },
              backlogSize: { type: 'number' },
              slaComplianceRate: { type: 'number' }
            }
          }
        },
        predictions: {
          type: 'object',
          properties: {
            projectedBacklogSize: { type: 'number' },
            capacityNeeded: { type: 'string' },
            riskForecast: { type: 'string' }
          }
        },
        recommendations: {
          type: 'array',
          items: { type: 'string' }
        },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'trend-analysis']
}));

// Phase 11: Generate Compliance Reports
export const generateComplianceReportsTask = defineTask('generate-compliance-reports', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 11: Generate Compliance Reports - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Security Compliance Specialist',
      task: 'Generate vulnerability management compliance reports for specified frameworks',
      context: {
        projectName: args.projectName,
        vulnerabilities: args.vulnerabilities,
        metrics: args.metrics,
        complianceFrameworks: args.complianceFrameworks,
        remediationStatus: args.remediationStatus,
        outputDir: args.outputDir
      },
      instructions: [
        '1. For each compliance framework, generate report:',
        '   - PCI-DSS: Requirement 6 (Vulnerability Management)',
        '     * Quarterly vulnerability scans',
        '     * Critical vulnerability remediation within timeframes',
        '     * Scan coverage and documentation',
        '   - SOC 2: CC6.8 and CC7.1 (Vulnerability Management)',
        '     * Vulnerability identification and assessment',
        '     * Timely remediation processes',
        '     * Monitoring and reporting',
        '   - ISO 27001: A.12.6 (Technical Vulnerability Management)',
        '     * Regular vulnerability assessments',
        '     * Risk-based prioritization',
        '     * Remediation tracking',
        '   - NIST CSF: ID.RA, PR.IP (Identify and Protect)',
        '     * Asset vulnerability identification',
        '     * Protective technology implementation',
        '2. Map vulnerabilities to compliance requirements',
        '3. Assess compliance status:',
        '   - Compliant: Meeting all requirements',
        '   - Non-compliant: Gaps or violations',
        '   - Partially compliant: Some requirements met',
        '4. Identify compliance gaps:',
        '   - Missing scans or assessments',
        '   - Overdue remediations',
        '   - Insufficient coverage',
        '   - Documentation gaps',
        '5. Calculate compliance score per framework',
        '6. Generate evidence artifacts:',
        '   - Scan reports',
        '   - Remediation records',
        '   - SLA compliance documentation',
        '   - Metrics dashboards',
        '7. Create compliance summary dashboard',
        '8. Generate auditor-friendly compliance report for each framework'
      ],
      outputFormat: 'JSON object with compliance reports'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'reportsGenerated', 'complianceScore', 'complianceGaps', 'complianceStatus', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        reportsGenerated: { type: 'number' },
        complianceScore: { type: 'number', description: 'Overall compliance score 0-100' },
        complianceGaps: { type: 'number', description: 'Number of compliance gaps identified' },
        complianceStatus: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              framework: { type: 'string' },
              status: { type: 'string', enum: ['compliant', 'partially-compliant', 'non-compliant'] },
              score: { type: 'number' },
              gaps: { type: 'array', items: { type: 'string' } },
              reportPath: { type: 'string' }
            }
          }
        },
        evidenceArtifacts: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              framework: { type: 'string' },
              evidenceType: { type: 'string' },
              path: { type: 'string' }
            }
          }
        },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'compliance']
}));

// Phase 12: Generate Documentation
export const generateDocumentationTask = defineTask('generate-documentation', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 12: Generate Vulnerability Management Documentation - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Security Documentation Specialist',
      task: 'Generate comprehensive vulnerability management documentation',
      context: {
        projectName: args.projectName,
        assetInventoryResult: args.assetInventoryResult,
        scanningResult: args.scanningResult,
        validationResult: args.validationResult,
        prioritizationResult: args.prioritizationResult,
        assignmentResult: args.assignmentResult,
        trackingResult: args.trackingResult,
        verificationResult: args.verificationResult,
        metricsResult: args.metricsResult,
        trendAnalysisResult: args.trendAnalysisResult,
        complianceFrameworks: args.complianceFrameworks,
        outputDir: args.outputDir
      },
      instructions: [
        '1. Create executive summary:',
        '   - Overall vulnerability posture',
        '   - Key metrics (MTTD, MTTR, backlog)',
        '   - Critical findings and actions taken',
        '   - Compliance status',
        '2. Document vulnerability management process:',
        '   - Asset inventory and discovery',
        '   - Scanning methodology and tools',
        '   - Validation and deduplication process',
        '   - Prioritization methodology (CVSS/EPSS)',
        '   - Remediation workflow',
        '   - Verification process',
        '3. Document current vulnerability status:',
        '   - Total vulnerabilities by severity',
        '   - Open vs remediated breakdown',
        '   - Top 10 critical vulnerabilities',
        '   - CISA KEV matches',
        '   - Vulnerability heat map',
        '4. Document remediation status:',
        '   - Tickets created and assigned',
        '   - Remediation progress by team',
        '   - SLA compliance',
        '   - Auto-remediation results',
        '5. Document metrics and trends:',
        '   - MTTD/MTTR metrics with trends',
        '   - Remediation velocity',
        '   - Backlog analysis',
        '   - Risk hotspots',
        '6. Include visualizations:',
        '   - Vulnerability trends chart',
        '   - Severity distribution pie chart',
        '   - MTTR by severity bar chart',
        '   - SLA compliance dashboard',
        '7. Add appendices:',
        '   - Scanner configurations',
        '   - Prioritization scoring formula',
        '   - SLA definitions',
        '   - Tool integration details',
        '8. Format as professional Markdown report'
      ],
      outputFormat: 'JSON object with documentation paths'
    },
    outputSchema: {
      type: 'object',
      required: ['success', 'reportPath', 'artifacts'],
      properties: {
        success: { type: 'boolean' },
        reportPath: { type: 'string', description: 'Main vulnerability management report path' },
        executiveSummaryPath: { type: 'string' },
        executiveSummary: { type: 'string', description: 'Brief executive summary text' },
        keyFindings: { type: 'array', items: { type: 'string' } },
        recommendations: { type: 'array', items: { type: 'string' } },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'documentation']
}));

// Phase 13: Calculate Vulnerability Score
export const calculateVulnerabilityScoreTask = defineTask('calculate-vulnerability-score', (args, taskCtx) => ({
  kind: 'agent',
  title: `Phase 13: Calculate Vulnerability Management Score - ${args.projectName}`,
  agent: {
    name: 'general-purpose',
    prompt: {
      role: 'Vulnerability Management Assessment Specialist',
      task: 'Calculate vulnerability management effectiveness score and provide assessment',
      context: {
        projectName: args.projectName,
        metrics: args.metrics,
        scanningResult: args.scanningResult,
        prioritizationResult: args.prioritizationResult,
        remediationStatus: args.remediationStatus,
        verificationResult: args.verificationResult,
        slaTargets: args.slaTargets,
        outputDir: args.outputDir
      },
      instructions: [
        '1. Calculate weighted vulnerability management score (0-100):',
        '   - Scanning Coverage (20% weight):',
        '     * Asset coverage percentage',
        '     * Scan frequency and recency',
        '     * Scanner diversity',
        '   - Detection Effectiveness (15% weight):',
        '     * MTTD performance vs benchmark',
        '     * False positive rate (lower is better)',
        '     * Validation rate',
        '   - Prioritization Quality (15% weight):',
        '     * Use of CVSS and EPSS',
        '     * CISA KEV integration',
        '     * Business context incorporation',
        '   - Remediation Performance (30% weight):',
        '     * MTTR performance vs benchmark',
        '     * SLA compliance rate',
        '     * Remediation rate vs discovery rate',
        '     * Backlog size and age',
        '   - Verification Process (10% weight):',
        '     * Verification rate',
        '     * Reopen rate (lower is better)',
        '     * Fix effectiveness',
        '   - Process Maturity (10% weight):',
        '     * Automation level',
        '     * Integration with ticketing',
        '     * Continuous scanning',
        '     * Metrics tracking',
        '2. Assess vulnerability posture:',
        '   - Excellent (90-100): Best-in-class program',
        '   - Good (75-89): Strong program with minor gaps',
        '   - Acceptable (60-74): Adequate but needs improvement',
        '   - Needs Improvement (0-59): Significant gaps',
        '3. Evaluate critical risk:',
        '   - Open critical vulnerabilities',
        '   - CISA KEV matches',
        '   - SLA breaches on high/critical',
        '4. Assess program maturity:',
        '   - Ad-hoc (manual, reactive)',
        '   - Repeatable (documented, some automation)',
        '   - Defined (standardized, integrated)',
        '   - Managed (metrics-driven, optimized)',
        '   - Optimized (continuous improvement, proactive)',
        '5. Identify strengths and improvement areas',
        '6. Provide actionable recommendations prioritized by impact',
        '7. Generate assessment summary document'
      ],
      outputFormat: 'JSON object with vulnerability management assessment'
    },
    outputSchema: {
      type: 'object',
      required: ['vulnerabilityScore', 'verdict', 'recommendation', 'summaryPath', 'artifacts'],
      properties: {
        vulnerabilityScore: { type: 'number', minimum: 0, maximum: 100 },
        componentScores: {
          type: 'object',
          properties: {
            scanningCoverage: { type: 'number' },
            detectionEffectiveness: { type: 'number' },
            prioritizationQuality: { type: 'number' },
            remediationPerformance: { type: 'number' },
            verificationProcess: { type: 'number' },
            processMaturity: { type: 'number' }
          }
        },
        vulnerabilityPosture: { type: 'string', enum: ['excellent', 'good', 'acceptable', 'needs-improvement'] },
        criticalRiskLevel: { type: 'string', enum: ['low', 'medium', 'high', 'critical'] },
        programMaturity: { type: 'string', enum: ['ad-hoc', 'repeatable', 'defined', 'managed', 'optimized'] },
        verdict: { type: 'string', description: 'Overall assessment verdict' },
        recommendation: { type: 'string', description: 'Top priority recommendation' },
        strengths: { type: 'array', items: { type: 'string' } },
        improvements: { type: 'array', items: { type: 'string' } },
        prioritizedRecommendations: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              priority: { type: 'string', enum: ['high', 'medium', 'low'] },
              recommendation: { type: 'string' },
              impact: { type: 'string' }
            }
          }
        },
        summaryPath: { type: 'string' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'vulnerability-management', 'scoring']
}));
